/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Canvas2DocumentPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var path = __toESM(require("path"));
var Canvas2DocumentPlugin = class extends import_obsidian.Plugin {
  async onload() {
    if (this.app.vault.adapter instanceof import_obsidian.FileSystemAdapter) {
      this.fsadapter = this.app.vault.adapter;
    } else {
      return;
    }
    this.addCommand({
      id: "run-conversion",
      name: "Step 1 - Convert canvas to a longform document",
      callback: async () => {
        const canvStruct = await this.readCanvasStruct();
        if (canvStruct == false) {
          new import_obsidian.Notice(`this is not a canvas file`);
          return;
        }
        let [contents, myparsed_data] = await this.readCanvasData(canvStruct);
        const result = await this.writeCanvDocFile(contents, canvStruct, myparsed_data);
      }
    });
    this.addCommand({
      id: "run-redoc",
      name: "Step 2 - Clear canvas2document target document",
      callback: async () => {
        const canvStruct = await this.readC2Dtarget();
        if (canvStruct == false) {
          new import_obsidian.Notice(`this is not a canvas2document target file`);
          return;
        }
        this.writeC2Doc(canvStruct);
      }
    });
  }
  onunload() {
  }
  async readC2Dtarget() {
    let activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || !activeFile.name.includes("_fromCanvas.md")) {
      return false;
    } else {
      let mdFolderPath = path.dirname(activeFile.path);
    }
    let content = this.app.vault.cachedRead(activeFile);
    return content;
  }
  async writeC2Doc(canvStruct) {
    let activeFile = this.app.workspace.getActiveFile();
    let mdFolderPath = path.dirname(activeFile.path);
    const pattern = /\!\[\[([^[\]]+)\]\]/g;
    const matches = canvStruct.match(pattern);
    let doccontentstring = "> [!success] This is your converted and cleared document from Canvas2Document\n> (you can delete this infobox)\n\n";
    if (!matches) {
      return;
    }
    let textfilenames = [];
    let filenames = [];
    matches.forEach((match) => {
      let embeddedfilename = match.replace(/\!\[\[(.*)\]\]/, "$1");
      if (embeddedfilename.endsWith(".md")) {
        if (embeddedfilename.startsWith("./")) {
          embeddedfilename = embeddedfilename.replace("./", "");
        }
        textfilenames.push(embeddedfilename);
      }
      filenames.push(embeddedfilename);
    });
    const fileContents = await Promise.all(
      textfilenames.map(
        async (file) => [file, await this.app.vault.cachedRead(this.app.vault.getAbstractFileByPath(file))]
      )
    );
    for (const xfile of filenames) {
      if (xfile.endsWith(".md")) {
        const found = fileContents.find((element) => element[0] == xfile);
        const { dir, name, ext } = path.parse(xfile);
        if (!dir.endsWith("_canvas2doc-data")) {
          doccontentstring += "# " + name + "\n\n";
        }
        doccontentstring += found[1] + "\n\n";
      } else {
        doccontentstring += "![[" + xfile + "]]\n\n";
      }
    }
    let docFilename;
    if (mdFolderPath == ".") {
      docFilename = activeFile.basename + "_fromC2D.md";
    } else {
      docFilename = mdFolderPath + "/" + activeFile.basename + "_fromC2D.md";
    }
    try {
      const exists = await this.fsadapter.exists(docFilename);
      if (exists) {
        const confirmed = await new Promise((resolve) => {
          const notice = new import_obsidian.Notice("File " + docFilename + " already exists. Overwrite?", 0);
          notice.noticeEl.createEl("button", { text: "Yes" }).onclick = () => {
            notice.hide();
            resolve(true);
          };
          notice.noticeEl.createEl("button", { text: "No" }).onclick = () => {
            notice.hide();
            resolve(false);
          };
        });
        if (!confirmed) {
          return false;
        }
      }
      await this.fsadapter.write(docFilename, doccontentstring);
    } catch (e) {
      console.log("error writing the new cleared doc file " + e);
    }
    const docftab = await this.app.vault.getAbstractFileByPath(docFilename);
    try {
      await this.app.workspace.getLeaf("split").openFile(docftab);
    } catch (e) {
      console.log(e);
    }
    return;
  }
  async readCanvasStruct() {
    let activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension != "canvas") {
      return false;
    } else {
      let mdFolderPath = path.dirname(activeFile.path);
    }
    let content = this.app.vault.cachedRead(activeFile);
    return content;
  }
  async findAllXChildren(startGeneration, myparsed_data, fileContents, handledNodes, limitrecurseNodes, runcounterfunc, runcounterforeach) {
    runcounterfunc++;
    if (runcounterfunc > 30) {
      return false;
    }
    for (const child of startGeneration) {
      runcounterforeach++;
      if (runcounterforeach > myparsed_data.edges2.length) {
        return false;
      }
      const nodeentry = myparsed_data.nodes.find((entry) => entry.id === child);
      if (!handledNodes.has(child)) {
        const result = await this.formatNode(nodeentry, 6);
        fileContents.push(result);
        handledNodes.add(child);
      } else {
        limitrecurseNodes++;
        if (limitrecurseNodes > 30) {
          return false;
        }
      }
      let children = myparsed_data.edges2.filter((edge) => edge.fromNode === child).map((edge) => edge.toNode);
      if (children.length > 0) {
        const continueRecursion = await this.findAllXChildren(children, myparsed_data, fileContents, handledNodes, limitrecurseNodes, runcounterfunc, runcounterforeach);
        if (!continueRecursion)
          return false;
      }
    }
    ;
    limitrecurseNodes++;
    return limitrecurseNodes <= 30;
  }
  async traverseNodes(initialNodes, myparsed_data, fileContents, handledNodes) {
    for (const node of initialNodes) {
      const nodeentry = myparsed_data.nodes.find((entry) => entry.id === node);
      if (!handledNodes.has(node)) {
        const result = await this.formatNode(nodeentry, 1);
        fileContents.push(result);
      }
      handledNodes.add(node);
      const children1 = myparsed_data.edges2.filter((edge) => edge.fromNode === node).map((edge) => edge.toNode);
      for (const child1 of children1) {
        const nodeentry2 = myparsed_data.nodes.find((entry) => entry.id === child1);
        if (!handledNodes.has(child1)) {
          const result = await this.formatNode(nodeentry2, 2);
          fileContents.push(result);
        }
        handledNodes.add(child1);
        const children2 = myparsed_data.edges2.filter((edge) => edge.fromNode === child1).map((edge) => edge.toNode);
        for (const child2 of children2) {
          const nodeentry3 = myparsed_data.nodes.find((entry) => entry.id === child2);
          if (!handledNodes.has(child2)) {
            const result = await this.formatNode(nodeentry3, 3);
            fileContents.push(result);
          }
          handledNodes.add(child2);
          const children3 = myparsed_data.edges2.filter((edge) => edge.fromNode === child2).map((edge) => edge.toNode);
          for (const child3 of children3) {
            const nodeentry4 = myparsed_data.nodes.find((entry) => entry.id === child3);
            if (!handledNodes.has(child3)) {
              const result = await this.formatNode(nodeentry4, 4);
              fileContents.push(result);
            }
            handledNodes.add(child3);
            const children4 = myparsed_data.edges2.filter((edge) => edge.fromNode === child3).map((edge) => edge.toNode);
            for (const child4 of children4) {
              const nodeentry5 = myparsed_data.nodes.find((entry) => entry.id === child4);
              if (!handledNodes.has(child4)) {
                const result = await this.formatNode(nodeentry5, 5);
                fileContents.push(result);
              }
              handledNodes.add(child4);
              const children5 = myparsed_data.edges2.filter((edge) => edge.fromNode === child4).map((edge) => edge.toNode);
              for (const child5 of children5) {
                const nodeentry6 = myparsed_data.nodes.find((entry) => entry.id === child5);
                if (!handledNodes.has(child5)) {
                  const result2 = await this.formatNode(nodeentry6, 6);
                  fileContents.push(result2);
                }
                handledNodes.add(child5);
                const children6 = myparsed_data.edges2.filter((edge) => edge.fromNode === child5).map((edge) => edge.toNode);
                let runcounterfunc = 0;
                let runcounterforeach = 0;
                let limitrecurseNodes = 0;
                const result = await this.findAllXChildren(children6, myparsed_data, fileContents, handledNodes, limitrecurseNodes, runcounterfunc, runcounterforeach);
              }
            }
          }
        }
      }
    }
  }
  async readCanvasData(struct) {
    const fileContents = [];
    let myparsed_data = JSON.parse(struct);
    const singleNodeIDs = /* @__PURE__ */ new Set();
    const groupNodes = /* @__PURE__ */ new Set();
    myparsed_data.nodes.forEach((node) => {
      if (node.type === "group") {
        groupNodes.add(node.id);
      } else {
        singleNodeIDs.add(node.id);
      }
    });
    const fromNodes = /* @__PURE__ */ new Set();
    const toNodes = /* @__PURE__ */ new Set();
    let groupClearedEdges = [];
    let resa = await myparsed_data.edges.forEach((edge) => {
      if (groupNodes.has(edge.fromNode) || groupNodes.has(edge.toNode)) {
      } else {
        fromNodes.add(edge.fromNode);
        toNodes.add(edge.toNode);
        groupClearedEdges.push(edge);
      }
    });
    myparsed_data.edges2 = groupClearedEdges;
    let handledNodes = /* @__PURE__ */ new Set();
    const skiphandledNodes = true;
    let nodesWithoutParents = [...singleNodeIDs].filter((node) => !toNodes.has(node));
    if (nodesWithoutParents.length === 0) {
      nodesWithoutParents = [...singleNodeIDs];
    }
    const traverseresult = await this.traverseNodes(nodesWithoutParents, myparsed_data, fileContents, handledNodes);
    const diff = new Set([...singleNodeIDs].filter((x) => !handledNodes.has(x)));
    if (diff.size > 0) {
      const traverseresult2 = await this.traverseNodes(diff, myparsed_data, fileContents, handledNodes);
    }
    return [fileContents, myparsed_data];
  }
  async formatNode(node, level) {
    const id = node.id;
    const type = node.type;
    let nodefile = "";
    if (type === "file") {
      nodefile = node.file;
      const { name, ext } = path.parse(nodefile);
      if (ext === ".md") {
        return [id, type, nodefile, level, "textfile", name];
      } else if (ext === ".jpg" || ext == ".jpeg" || ext === ".png" || ext === ".gif") {
        return [id, type, nodefile, level, "contentimage", name + "." + ext];
      } else if (ext === ".pdf") {
        return [id, type, nodefile, level, "contentpdf", name + "." + ext];
      } else {
      }
    } else if (type === "link") {
      if (node.url.includes("youtube")) {
        const url = node.url;
        return [id, type, url, level, "contentyoutube", node.url];
      } else {
        return [id, type, node.url, level, "contentlink", node.url];
      }
    } else if (type === "text") {
      const text = node.text;
      const textPreview = text.substring(0, 100);
      return [id, type, "node", level, text, textPreview];
    }
  }
  async writeCanvDocFile(content, convStruct, myparsed_data) {
    let activeFile = this.app.workspace.getActiveFile();
    let mdFolderPath = path.dirname(activeFile.path);
    let writeworkdir = mdFolderPath + "/" + activeFile.basename + "_canvas2doc-data";
    this.fsadapter.mkdir(writeworkdir);
    let canvasFile;
    let canvasFilename;
    if (mdFolderPath == ".") {
      canvasFilename = activeFile.basename + "_fromCanvas.md";
    } else {
      canvasFilename = mdFolderPath + "/" + activeFile.basename + "_fromCanvas.md";
    }
    let contentString = "> [!info] This is an automatically generated document from Plugin [Canvas2Document](https://github.com/slnsys/obsidian-canvas2document)\n> arrange the document as you need with the outline, then call *Clear canvas2document target document*\n\n";
    for (const element of content) {
      let cnfname = "";
      let heading = "";
      for (let i = 0; i < element[3]; i++) {
        heading += "#";
      }
      if (element[1] == "text") {
        cnfname = writeworkdir + "/newdoc-node_" + element[0] + "_fromCanvas.md";
        contentString += "\n\n" + heading + " _card " + element[5] + "\n";
        contentString += element[2] + " ^" + element[0] + "\n\n";
        contentString += "> [!tip] link navigation from the canvas\n";
        for (const edge of myparsed_data.edges2) {
          if (edge.fromNode == element[0]) {
            const found = content.find((element2) => element2[0] == edge.toNode);
            const firstline = found[5].split("\n")[0];
            const found5 = firstline.replace(/#/g, "");
            contentString += "> linking to: [[#^" + edge.toNode + "|" + found5 + "]]\n";
          }
          if (edge.toNode == element[0]) {
            const found = content.find((element2) => element2[0] == edge.fromNode);
            const firstline = found[5].split("\n")[0];
            const found5 = firstline.replace(/#/g, "");
            contentString += "> linked from: [[#^" + edge.fromNode + "|" + found5 + "]]\n";
          }
        }
        contentString += "\n ![[" + cnfname + "]]\n\n";
        let canvasnodeFile;
        try {
          let cnfabst2 = this.app.vault.getAbstractFileByPath(cnfname);
          await this.fsadapter.write(cnfname, element[4]);
        } catch (e) {
          console.log(e);
          return;
        }
      } else if (element[1] == "link") {
        contentString += "\n\n" + heading + " _link " + element[5] + "\n";
        contentString += element[2] + " ^" + element[0] + "\n\n";
        contentString += "> [!tip] link navigation from the canvas\n";
        for (const edge of myparsed_data.edges2) {
          if (edge.fromNode == element[0]) {
            const found = content.find((element2) => element2[0] == edge.toNode);
            const firstline = found[5].split("\n")[0];
            const found5 = firstline.replace(/#/g, "");
            contentString += "> linking to: [[#^" + edge.toNode + "|" + found5 + "]]\n";
          }
          if (edge.toNode == element[0]) {
            const found = content.find((element2) => element2[0] == edge.fromNode);
            const firstline = found[5].split("\n")[0];
            const found5 = firstline.replace(/#/g, "");
            contentString += "> linked from: [[#^" + edge.fromNode + "|" + found5 + "]]\n";
          }
        }
        if (element[4] == "contentyoutube") {
          contentString += "\n ![](" + element[2] + ")\n\n";
        } else if (element[4] == "contentlink") {
          contentString += '\n <iframe src="' + element[2] + '"></iframe>\n\n';
        }
      } else if (element[1] == "file") {
        if (element[4] == "contentimage" || element[4] == "contentpdf") {
          contentString += "\n\n" + heading + " _Media " + element[5] + "\n";
          contentString += element[2] + " ^" + element[0] + "\n\n";
          contentString += "> [!tip] link navigation from the canvas\n";
          for (const edge of myparsed_data.edges2) {
            if (edge.fromNode == element[0]) {
              const found = content.find((element2) => element2[0] == edge.toNode);
              const firstline = found[5].split("\n")[0];
              const found5 = firstline.replace(/#/g, "");
              contentString += "> linking to: [[#^" + edge.toNode + "|" + found5 + "]]\n";
            }
            if (edge.toNode == element[0]) {
              const found = content.find((element2) => element2[0] == edge.fromNode);
              const firstline = found[5].split("\n")[0];
              const found5 = firstline.replace(/#/g, "");
              contentString += "> linked from: [[#^" + edge.fromNode + "|" + found5 + "]]\n";
            }
          }
          if (element[4] == "contentpdf") {
            contentString += "\n ![[" + element[2] + "#height=500]]\n\n";
          } else if (element[4] == "contentimage") {
            contentString += "\n ![[" + element[2] + "|500]]\n\n";
          }
        } else {
          contentString += "\n\n" + heading + " _noteFile " + element[5] + "\n";
          contentString += element[2] + " ^" + element[0] + "\n\n";
          contentString += "> [!tip] link navigation from the canvas\n";
          for (const edge of myparsed_data.edges2) {
            if (edge.fromNode == element[0]) {
              const found = content.find((element2) => element2[0] == edge.toNode);
              const firstline = found[5].split("\n")[0];
              const found5 = firstline.replace(/#/g, "");
              contentString += "> linking to: [[#^" + edge.toNode + "|" + found5 + "]]\n";
            }
            if (edge.toNode == element[0]) {
              const found = content.find((element2) => element2[0] == edge.fromNode);
              const firstline = found[5].split("\n")[0];
              const found5 = firstline.replace(/#/g, "");
              contentString += "> linked from: [[#^" + edge.fromNode + "|" + found5 + "]]\n";
            }
          }
          contentString += "\n ![[" + element[2] + "]]\n\n";
        }
      }
    }
    try {
      const exists = await this.fsadapter.exists(canvasFilename);
      if (exists) {
        const confirmed = await new Promise((resolve) => {
          const notice = new import_obsidian.Notice("File " + canvasFilename + " already exists. Overwrite?", 0);
          notice.noticeEl.createEl("button", { text: "Yes" }).onclick = () => {
            notice.hide();
            resolve(true);
          };
          notice.noticeEl.createEl("button", { text: "No" }).onclick = () => {
            notice.hide();
            resolve(false);
          };
        });
        if (!confirmed) {
          return false;
        }
      }
      await this.fsadapter.write(canvasFilename, contentString);
    } catch (e) {
      console.log("error writing the new doc file " + e);
    }
    const cnfabst = await this.app.vault.getAbstractFileByPath(canvasFilename);
    try {
      await this.app.workspace.getLeaf("split").openFile(cnfabst);
    } catch (e) {
      console.log(e);
    }
    return true;
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgbm9ybWFsaXplUGF0aCwgV29ya3NwYWNlLCBXb3Jrc3BhY2VMZWFmLCBURmlsZSwgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTm90aWNlLCBQbHVnaW4sIEZpbGVTeXN0ZW1BZGFwdGVyIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG4vLyBpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7IGV4aXQgfSBmcm9tICdwcm9jZXNzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbnZhczJEb2N1bWVudFBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XHJcblx0ZnNhZGFwdGVyOiBGaWxlU3lzdGVtQWRhcHRlcjtcclxuXHJcblx0YXN5bmMgb25sb2FkKCkge1xyXG5cdFxyXG5cdFx0Ly8gdGhpcy5mc2FkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyIGFzIEZpbGVTeXN0ZW1BZGFwdGVyO1xyXG5cdFx0IGlmICh0aGlzLmFwcC52YXVsdC5hZGFwdGVyIGluc3RhbmNlb2YgRmlsZVN5c3RlbUFkYXB0ZXIpIHtcclxuXHRcdFx0dGhpcy5mc2FkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyIGFzIEZpbGVTeXN0ZW1BZGFwdGVyO1xyXG5cdFx0IH0gZWxzZSB7XHJcblx0XHRcdC8vVE9ETyB0aHJvdyBleGNlcHRpb24gZm9yIGZzYWRhcHRlclxyXG5cdFx0XHRyZXR1cm5cclxuXHRcdCB9XHJcblxyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQ6IFwicnVuLWNvbnZlcnNpb25cIixcclxuXHRcdFx0bmFtZTogXCJTdGVwIDEgLSBDb252ZXJ0IGNhbnZhcyB0byBhIGxvbmdmb3JtIGRvY3VtZW50XCIsXHJcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgY2FudlN0cnVjdCA9IGF3YWl0IHRoaXMucmVhZENhbnZhc1N0cnVjdCgpO1xyXG5cdFx0XHRcdGlmIChjYW52U3RydWN0ID09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRuZXcgTm90aWNlKGB0aGlzIGlzIG5vdCBhIGNhbnZhcyBmaWxlYCk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsZXQgW2NvbnRlbnRzLCBteXBhcnNlZF9kYXRhXSA9IGF3YWl0IHRoaXMucmVhZENhbnZhc0RhdGEoY2FudlN0cnVjdCk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMud3JpdGVDYW52RG9jRmlsZShjb250ZW50cywgY2FudlN0cnVjdCwgbXlwYXJzZWRfZGF0YSk7XHJcblxyXG5cdFx0XHR9LFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcclxuXHRcdFx0aWQ6IFwicnVuLXJlZG9jXCIsXHJcblx0XHRcdG5hbWU6IFwiU3RlcCAyIC0gQ2xlYXIgY2FudmFzMmRvY3VtZW50IHRhcmdldCBkb2N1bWVudFwiLFxyXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGNhbnZTdHJ1Y3QgPSBhd2FpdCB0aGlzLnJlYWRDMkR0YXJnZXQoKTtcclxuXHRcdFx0XHRpZiAoY2FudlN0cnVjdCA9PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0bmV3IE5vdGljZShgdGhpcyBpcyBub3QgYSBjYW52YXMyZG9jdW1lbnQgdGFyZ2V0IGZpbGVgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy53cml0ZUMyRG9jKGNhbnZTdHJ1Y3QpO1xyXG5cdFx0XHR9LFxyXG5cdFx0fSk7XHJcblxyXG5cdH1cclxuXHJcblx0b251bmxvYWQoKSB7XHJcblx0XHQvLyBUT0RPIGNsZWFuaW5nIHVwXHJcblx0fVxyXG5cclxuXHRhc3luYyByZWFkQzJEdGFyZ2V0KCk6IFByb21pc2U8bnVtYmVyPiB7XHJcblx0XHQvKlxyXG5cdFx0Y2hlY2sgb24gYWN0aXZlIGZpbGUgaXMgY2FudmFzXHJcblx0XHQqL1xyXG5cdFx0bGV0IGFjdGl2ZUZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xyXG5cclxuXHRcdC8vZmlsZW5hbWUgb2YgdGhlIGFjdGl2ZSBmaWxlIGNvbnRhaW5zIFwiX2Zyb21DYW52YXMubWRcIlxyXG5cdFx0aWYgKCFhY3RpdmVGaWxlIHx8ICFhY3RpdmVGaWxlLm5hbWUuaW5jbHVkZXMoXCJfZnJvbUNhbnZhcy5tZFwiKSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgbWRGb2xkZXJQYXRoOiBzdHJpbmcgPSBwYXRoLmRpcm5hbWUoYWN0aXZlRmlsZS5wYXRoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUT0RPOiBwcmV2ZW50IHJlYWRpbmcgYWxsIGZpbGVzLCBqdXN0IHRoZSBhY3RpdmUgZmlsZSwgaWYgY2FudmFzIGNoZWNrIG9rXHJcblxyXG5cdFx0Ly9sZXQgYWN0Y2FudmFzZmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoYWN0aXZlRmlsZSk7XHJcblx0XHRsZXQgY29udGVudCA9IHRoaXMuYXBwLnZhdWx0LmNhY2hlZFJlYWQoYWN0aXZlRmlsZSk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRlbnQ7XHJcblx0fVx0XHJcblxyXG5cclxuXHRhc3luYyB3cml0ZUMyRG9jKGNhbnZTdHJ1Y3QpIHtcclxuXHJcblx0XHRsZXQgYWN0aXZlRmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XHJcblx0XHRsZXQgbWRGb2xkZXJQYXRoOiBzdHJpbmcgPSBwYXRoLmRpcm5hbWUoYWN0aXZlRmlsZS5wYXRoKTtcclxuXHJcblx0XHQvLyBUT0RPIGFsc28gZm9yIGxpbmtzLCBub3QganVzdCBlbWJlZGRpbmdzXHJcblx0XHRjb25zdCBwYXR0ZXJuID0gL1xcIVxcW1xcWyhbXltcXF1dKylcXF1cXF0vZztcclxuXHRcdGNvbnN0IG1hdGNoZXMgPSBjYW52U3RydWN0Lm1hdGNoKHBhdHRlcm4pO1xyXG5cclxuXHRcdGxldCBkb2Njb250ZW50c3RyaW5nID0gXCI+IFshc3VjY2Vzc10gVGhpcyBpcyB5b3VyIGNvbnZlcnRlZCBhbmQgY2xlYXJlZCBkb2N1bWVudCBmcm9tIENhbnZhczJEb2N1bWVudFxcblxcPiAoeW91IGNhbiBkZWxldGUgdGhpcyBpbmZvYm94KVxcblxcblwiXHJcblxyXG5cdFx0aWYgKCEgbWF0Y2hlcykge1xyXG5cdFx0XHRyZXR1cm5cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdGV4dGZpbGVuYW1lcyA9IFtdXHJcblx0XHRsZXQgZmlsZW5hbWVzID0gW11cclxuXHJcblx0XHRtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xyXG5cdFx0XHRsZXQgZW1iZWRkZWRmaWxlbmFtZSA9IG1hdGNoLnJlcGxhY2UoL1xcIVxcW1xcWyguKilcXF1cXF0vLCAnJDEnKTtcclxuXHJcblx0XHRcdGlmIChlbWJlZGRlZGZpbGVuYW1lLmVuZHNXaXRoKFwiLm1kXCIpKSB7XHJcblx0XHRcdFx0Ly8gaWYgZW1iZWRkZWRmaWxlbmFtZSBzdGFydHMgd2l0aCBcIi4vXCIgcmVtb3ZlIGl0XHJcblx0XHRcdFx0aWYgKGVtYmVkZGVkZmlsZW5hbWUuc3RhcnRzV2l0aChcIi4vXCIpKSB7XHJcblx0XHRcdFx0XHRlbWJlZGRlZGZpbGVuYW1lID0gZW1iZWRkZWRmaWxlbmFtZS5yZXBsYWNlKFwiLi9cIiwgXCJcIilcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGV4dGZpbGVuYW1lcy5wdXNoKGVtYmVkZGVkZmlsZW5hbWUpO1xyXG5cdFx0XHR9IFxyXG5cclxuXHRcdFx0ZmlsZW5hbWVzLnB1c2goZW1iZWRkZWRmaWxlbmFtZSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb25zdCBmaWxlQ29udGVudHMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuXHRcdFx0dGV4dGZpbGVuYW1lcy5tYXAoXHJcblx0XHRcdCAgYXN5bmMgKGZpbGUpID0+IFtmaWxlLCBhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlKSldIGFzIGNvbnN0LFxyXG5cdFx0XHQpLFxyXG5cdCAgICApO1xyXG5cclxuXHRcdGZvciAoY29uc3QgeGZpbGUgb2YgZmlsZW5hbWVzKSB7XHJcblx0XHRcdGlmICh4ZmlsZS5lbmRzV2l0aChcIi5tZFwiKSkge1xyXG5cdFx0XHRcdGNvbnN0IGZvdW5kID0gZmlsZUNvbnRlbnRzLmZpbmQoKGVsZW1lbnQpID0+IGVsZW1lbnRbMF0gPT0geGZpbGUpO1xyXG5cclxuXHRcdFx0XHRjb25zdCB7IGRpciwgbmFtZSwgZXh0IH0gPSBwYXRoLnBhcnNlKHhmaWxlKTtcclxuXHJcblx0XHRcdFx0aWYgKCEgZGlyLmVuZHNXaXRoKFwiX2NhbnZhczJkb2MtZGF0YVwiKSkge1xyXG5cdFx0XHRcdFx0ZG9jY29udGVudHN0cmluZyArPSBcIiMgXCIgKyBuYW1lICsgXCJcXG5cXG5cIlxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZG9jY29udGVudHN0cmluZyArPSBmb3VuZFsxXSArIFwiXFxuXFxuXCJcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRkb2Njb250ZW50c3RyaW5nICs9IFwiIVtbXCIgKyB4ZmlsZSArIFwiXV1cXG5cXG5cIlxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGRvY0ZpbGVuYW1lXHJcblx0XHRpZiAobWRGb2xkZXJQYXRoID09IFwiLlwiKSB7XHJcblx0ICAgIFx0ZG9jRmlsZW5hbWUgPSBhY3RpdmVGaWxlLmJhc2VuYW1lICsgXCJfZnJvbUMyRC5tZFwiXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkb2NGaWxlbmFtZSA9IG1kRm9sZGVyUGF0aCArIFwiL1wiICsgYWN0aXZlRmlsZS5iYXNlbmFtZSArIFwiX2Zyb21DMkQubWRcIlx0XHRcdFx0XHRcclxuXHRcdH1cclxuXHJcblx0XHR0cnkge1xyXG5cclxuXHJcblx0XHRcdGNvbnN0IGV4aXN0cyA9IGF3YWl0IHRoaXMuZnNhZGFwdGVyLmV4aXN0cyhkb2NGaWxlbmFtZSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdGlmIChleGlzdHMpIHtcclxuXHRcdFx0ICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuXHRcdFx0XHRjb25zdCBub3RpY2UgPSBuZXcgTm90aWNlKCdGaWxlICcgKyBkb2NGaWxlbmFtZSArICcgYWxyZWFkeSBleGlzdHMuIE92ZXJ3cml0ZT8nLCAwKTtcclxuXHRcdFx0XHRub3RpY2Uubm90aWNlRWwuY3JlYXRlRWwoJ2J1dHRvbicsIHt0ZXh0OiAnWWVzJ30pLm9uY2xpY2sgPSAoKSA9PiB7XHJcblx0XHRcdFx0ICBub3RpY2UuaGlkZSgpO1xyXG5cdFx0XHRcdCAgcmVzb2x2ZSh0cnVlKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdG5vdGljZS5ub3RpY2VFbC5jcmVhdGVFbCgnYnV0dG9uJywge3RleHQ6ICdObyd9KS5vbmNsaWNrID0gKCkgPT4ge1xyXG5cdFx0XHRcdCAgbm90aWNlLmhpZGUoKTtcclxuXHRcdFx0XHQgIHJlc29sdmUoZmFsc2UpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdCAgfSk7XHJcblx0XHRcdCAgXHJcblx0XHRcdCAgaWYgKCFjb25maXJtZWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIFVzZXIgY2hvc2Ugbm90IHRvIG92ZXJ3cml0ZVxyXG5cdFx0XHQgIH1cclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0YXdhaXQgdGhpcy5mc2FkYXB0ZXIud3JpdGUoZG9jRmlsZW5hbWUsIGRvY2NvbnRlbnRzdHJpbmcpO1xyXG5cclxuXHJcblxyXG5cclxuXHRcdFx0Ly8gYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKGRvY0ZpbGVuYW1lLCBkb2Njb250ZW50c3RyaW5nKVxyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcImVycm9yIHdyaXRpbmcgdGhlIG5ldyBjbGVhcmVkIGRvYyBmaWxlIFwiICsgZSlcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkb2NmdGFiID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGRvY0ZpbGVuYW1lKTtcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZignc3BsaXQnKS5vcGVuRmlsZShkb2NmdGFiKTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Y29uc29sZS5sb2coZSlcclxuXHRcdH1cclxuXHRcdHJldHVyblxyXG5cdH1cclxuXHJcblx0YXN5bmMgcmVhZENhbnZhc1N0cnVjdCgpOiBQcm9taXNlPG51bWJlcj4ge1xyXG5cdFx0LypcclxuXHRcdGNoZWNrIG9uIGFjdGl2ZSBmaWxlIGlzIGNhbnZhc1xyXG5cdFx0Ki9cclxuXHRcdGxldCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuXHRcdGlmICghYWN0aXZlRmlsZSB8fCBhY3RpdmVGaWxlLmV4dGVuc2lvbiAhPSBcImNhbnZhc1wiKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBtZEZvbGRlclBhdGg6IHN0cmluZyA9IHBhdGguZGlybmFtZShhY3RpdmVGaWxlLnBhdGgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE86IHByZXZlbnQgcmVhZGluZyBhbGwgZmlsZXMsIGp1c3QgdGhlIGFjdGl2ZSBmaWxlLCBpZiBjYW52YXMgY2hlY2sgb2tcclxuXHJcblx0XHQvL2xldCBhY3RjYW52YXNmaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChhY3RpdmVGaWxlKTtcclxuXHRcdGxldCBjb250ZW50ID0gdGhpcy5hcHAudmF1bHQuY2FjaGVkUmVhZChhY3RpdmVGaWxlKTtcclxuXHJcblx0XHRyZXR1cm4gY29udGVudDtcclxuXHR9XHRcclxuXHJcblx0YXN5bmMgZmluZEFsbFhDaGlsZHJlbihzdGFydEdlbmVyYXRpb24sIG15cGFyc2VkX2RhdGEsIGZpbGVDb250ZW50cywgaGFuZGxlZE5vZGVzLCBsaW1pdHJlY3Vyc2VOb2RlcywgcnVuY291bnRlcmZ1bmMsIHJ1bmNvdW50ZXJmb3JlYWNoKTpQcm9taXNlPGJvb2xlYW4+IHtcclxuXHJcblx0XHRydW5jb3VudGVyZnVuYysrXHJcblx0XHRpZiAocnVuY291bnRlcmZ1bmMgPiAzMCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2VcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGNvbnN0IGNoaWxkIG9mIHN0YXJ0R2VuZXJhdGlvbikge1xyXG5cdFx0XHRydW5jb3VudGVyZm9yZWFjaCsrXHJcblx0XHRcdGlmIChydW5jb3VudGVyZm9yZWFjaCA+IG15cGFyc2VkX2RhdGEuZWRnZXMyLmxlbmd0aCkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBub2RlZW50cnkgPSBteXBhcnNlZF9kYXRhLm5vZGVzLmZpbmQoZW50cnkgPT4gZW50cnkuaWQgPT09IGNoaWxkKTtcclxuXHRcclxuXHRcdFx0aWYgKCEgaGFuZGxlZE5vZGVzLmhhcyhjaGlsZCkpIHtcclxuXHRcdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmZvcm1hdE5vZGUobm9kZWVudHJ5LCA2KVxyXG5cdFx0XHRcdGZpbGVDb250ZW50cy5wdXNoKHJlc3VsdCk7XHJcblx0XHRcdFx0aGFuZGxlZE5vZGVzLmFkZChjaGlsZCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGltaXRyZWN1cnNlTm9kZXMrK1xyXG5cclxuXHRcdFx0XHRpZiAobGltaXRyZWN1cnNlTm9kZXMgPiAzMCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXQgY2hpbGRyZW4gPSBteXBhcnNlZF9kYXRhLmVkZ2VzMi5maWx0ZXIoZWRnZSA9PiBlZGdlLmZyb21Ob2RlID09PSBjaGlsZCkubWFwKGVkZ2UgPT4gZWRnZS50b05vZGUpO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRjb25zdCBjb250aW51ZVJlY3Vyc2lvbiA9IGF3YWl0IHRoaXMuZmluZEFsbFhDaGlsZHJlbihjaGlsZHJlbiwgbXlwYXJzZWRfZGF0YSwgZmlsZUNvbnRlbnRzLCBoYW5kbGVkTm9kZXMsIGxpbWl0cmVjdXJzZU5vZGVzLCBydW5jb3VudGVyZnVuYywgcnVuY291bnRlcmZvcmVhY2gpO1xyXG5cdFx0XHRcdGlmICghY29udGludWVSZWN1cnNpb24pIHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRsaW1pdHJlY3Vyc2VOb2RlcysrXHJcblx0XHRyZXR1cm4gbGltaXRyZWN1cnNlTm9kZXMgPD0gMzBcclxuXHR9XHJcblxyXG5cdFxyXG5cdGFzeW5jIHRyYXZlcnNlTm9kZXMoaW5pdGlhbE5vZGVzLCBteXBhcnNlZF9kYXRhLCBmaWxlQ29udGVudHMsIGhhbmRsZWROb2Rlcykge1xyXG5cclxuXHRcdGZvciAoY29uc3Qgbm9kZSBvZiBpbml0aWFsTm9kZXMpIHtcclxuXHJcblx0XHRcdGNvbnN0IG5vZGVlbnRyeSA9IG15cGFyc2VkX2RhdGEubm9kZXMuZmluZChlbnRyeSA9PiBlbnRyeS5pZCA9PT0gbm9kZSk7XHJcblxyXG5cdFx0XHQvLyBpcyAgc2tpcGhhbmRsZWROb2RlcyBpcyB0cnVlLCBjaGVjayBpZiBub2RlIGlzIGFscmVhZHkgaGFuZGxlZFxyXG5cdFx0XHRpZiAoISBoYW5kbGVkTm9kZXMuaGFzKG5vZGUpKSB7XHJcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5mb3JtYXROb2RlKG5vZGVlbnRyeSwgMSk7XHJcblx0XHRcdFx0ZmlsZUNvbnRlbnRzLnB1c2gocmVzdWx0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aGFuZGxlZE5vZGVzLmFkZChub2RlKTtcclxuXHJcblx0XHRcdGNvbnN0IGNoaWxkcmVuMSA9IG15cGFyc2VkX2RhdGEuZWRnZXMyXHJcblx0XHRcdC5maWx0ZXIoZWRnZSA9PiBlZGdlLmZyb21Ob2RlID09PSBub2RlKVxyXG5cdFx0XHQubWFwKGVkZ2UgPT4gZWRnZS50b05vZGUpO1xyXG5cdFxyXG5cdFx0XHRmb3IgKGNvbnN0IGNoaWxkMSBvZiBjaGlsZHJlbjEpIHtcclxuXHRcdFxyXG5cdFx0XHRcdGNvbnN0IG5vZGVlbnRyeSA9IG15cGFyc2VkX2RhdGEubm9kZXMuZmluZChlbnRyeSA9PiBlbnRyeS5pZCA9PT0gY2hpbGQxKTtcclxuXHJcblx0XHRcdFx0aWYgKCEgaGFuZGxlZE5vZGVzLmhhcyhjaGlsZDEpKSB7XHJcblx0XHRcdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmZvcm1hdE5vZGUobm9kZWVudHJ5LCAyKTtcclxuXHRcdFx0XHRcdGZpbGVDb250ZW50cy5wdXNoKHJlc3VsdCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRoYW5kbGVkTm9kZXMuYWRkKGNoaWxkMSk7XHJcblx0XHJcblx0XHRcdFx0Y29uc3QgY2hpbGRyZW4yID0gbXlwYXJzZWRfZGF0YS5lZGdlczJcclxuXHRcdFx0XHQuZmlsdGVyKGVkZ2UgPT4gZWRnZS5mcm9tTm9kZSA9PT0gY2hpbGQxKVxyXG5cdFx0XHRcdC5tYXAoZWRnZSA9PiBlZGdlLnRvTm9kZSk7XHJcblx0XHRcclxuXHRcdFx0XHRmb3IgKGNvbnN0IGNoaWxkMiBvZiBjaGlsZHJlbjIpIHtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBub2RlZW50cnkgPSBteXBhcnNlZF9kYXRhLm5vZGVzLmZpbmQoZW50cnkgPT4gZW50cnkuaWQgPT09IGNoaWxkMik7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCEgaGFuZGxlZE5vZGVzLmhhcyhjaGlsZDIpKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZm9ybWF0Tm9kZShub2RlZW50cnksIDMpO1xyXG5cdFx0XHRcdFx0XHRmaWxlQ29udGVudHMucHVzaChyZXN1bHQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGhhbmRsZWROb2Rlcy5hZGQoY2hpbGQyKTtcclxuXHJcblx0XHRcdFx0XHRjb25zdCBjaGlsZHJlbjMgPSBteXBhcnNlZF9kYXRhLmVkZ2VzMlxyXG5cdFx0XHRcdFx0LmZpbHRlcihlZGdlID0+IGVkZ2UuZnJvbU5vZGUgPT09IGNoaWxkMilcclxuXHRcdFx0XHRcdC5tYXAoZWRnZSA9PiBlZGdlLnRvTm9kZSk7XHJcblx0XHRcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcdGZvciAoY29uc3QgY2hpbGQzIG9mIGNoaWxkcmVuMykge1xyXG5cdFx0XHJcblx0XHRcdFx0XHRcdGNvbnN0IG5vZGVlbnRyeSA9IG15cGFyc2VkX2RhdGEubm9kZXMuZmluZChlbnRyeSA9PiBlbnRyeS5pZCA9PT0gY2hpbGQzKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICghIGhhbmRsZWROb2Rlcy5oYXMoY2hpbGQzKSkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZm9ybWF0Tm9kZShub2RlZW50cnksIDQpO1xyXG5cdFx0XHRcdFx0XHRcdGZpbGVDb250ZW50cy5wdXNoKHJlc3VsdCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdGhhbmRsZWROb2Rlcy5hZGQoY2hpbGQzKTtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnN0IGNoaWxkcmVuNCA9IG15cGFyc2VkX2RhdGEuZWRnZXMyXHJcblx0XHRcdFx0XHRcdC5maWx0ZXIoZWRnZSA9PiBlZGdlLmZyb21Ob2RlID09PSBjaGlsZDMpXHJcblx0XHRcdFx0XHRcdC5tYXAoZWRnZSA9PiBlZGdlLnRvTm9kZSk7XHJcblx0XHRcclxuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBjaGlsZDQgb2YgY2hpbGRyZW40KSB7XHJcblx0XHRcclxuXHRcdFx0XHRcdFx0XHRjb25zdCBub2RlZW50cnkgPSBteXBhcnNlZF9kYXRhLm5vZGVzLmZpbmQoZW50cnkgPT4gZW50cnkuaWQgPT09IGNoaWxkNCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICghIGhhbmRsZWROb2Rlcy5oYXMoY2hpbGQ0KSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5mb3JtYXROb2RlKG5vZGVlbnRyeSwgNSk7XHJcblx0XHRcdFx0XHRcdFx0XHRmaWxlQ29udGVudHMucHVzaChyZXN1bHQpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aGFuZGxlZE5vZGVzLmFkZChjaGlsZDQpO1xyXG5cdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRjb25zdCBjaGlsZHJlbjUgPSBteXBhcnNlZF9kYXRhLmVkZ2VzMlxyXG5cdFx0XHRcdFx0XHRcdC5maWx0ZXIoZWRnZSA9PiBlZGdlLmZyb21Ob2RlID09PSBjaGlsZDQpXHJcblx0XHRcdFx0XHRcdFx0Lm1hcChlZGdlID0+IGVkZ2UudG9Ob2RlKTtcclxuXHRcdFxyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGNoaWxkNSBvZiBjaGlsZHJlbjUpIHtcclxuXHRcdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IG5vZGVlbnRyeSA9IG15cGFyc2VkX2RhdGEubm9kZXMuZmluZChlbnRyeSA9PiBlbnRyeS5pZCA9PT0gY2hpbGQ1KTtcclxuXHRcclxuXHRcdFx0XHRcdFx0XHRcdGlmICghIGhhbmRsZWROb2Rlcy5oYXMoY2hpbGQ1KSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmZvcm1hdE5vZGUobm9kZWVudHJ5LCA2KTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZmlsZUNvbnRlbnRzLnB1c2gocmVzdWx0KTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHRoYW5kbGVkTm9kZXMuYWRkKGNoaWxkNSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBjaGlsZHJlbjYgPSBteXBhcnNlZF9kYXRhLmVkZ2VzMi5maWx0ZXIoZWRnZSA9PiBlZGdlLmZyb21Ob2RlID09PSBjaGlsZDUpLm1hcChlZGdlID0+IGVkZ2UudG9Ob2RlKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBub3cgdHVybiB0byBpbmZpbml0eSAtPiBmaW5kQWxsWENoaWxkcmVuKClcdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRcdFx0bGV0IHJ1bmNvdW50ZXJmdW5jOiBudW1iZXIgPSAwXHJcblx0XHRcdFx0XHRcdFx0XHRsZXQgcnVuY291bnRlcmZvcmVhY2g6IG51bWJlciA9IDBcclxuXHRcdFx0XHRcdFx0XHRcdGxldCBsaW1pdHJlY3Vyc2VOb2RlczogbnVtYmVyID0gMFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZmluZEFsbFhDaGlsZHJlbihjaGlsZHJlbjYsIG15cGFyc2VkX2RhdGEsIGZpbGVDb250ZW50cywgaGFuZGxlZE5vZGVzLCBsaW1pdHJlY3Vyc2VOb2RlcywgcnVuY291bnRlcmZ1bmMsIHJ1bmNvdW50ZXJmb3JlYWNoKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFzeW5jIHJlYWRDYW52YXNEYXRhKHN0cnVjdCkge1xyXG5cdFx0Ly8gVE9ETzogbm9jaG1hbCBuYWNoIGh0dHBzOi8vZG9jcy5vYnNpZGlhbi5tZC9QbHVnaW5zL1ZhdWx0LCByZWFkIGFsbCBmaWxlc1xyXG5cdFx0Ly8gaW5wdXQgbGlzdGUgZWJlbiBhdXMgY2FudmFzLUpTT04gYWxsZSBub2Rlc1xyXG5cclxuXHRcdGNvbnN0IGZpbGVDb250ZW50czogW3N0cmluZywgc3RyaW5nLCBzdHJpbmcsIG51bWJlciwgc3RyaW5nLCBzdHJpbmddW10gPSBbXTtcclxuXHJcblx0XHRsZXQgbXlwYXJzZWRfZGF0YSA9IEpTT04ucGFyc2Uoc3RydWN0KTtcclxuXHJcblx0XHRjb25zdCBzaW5nbGVOb2RlSURzID0gbmV3IFNldCgpO1xyXG5cdFx0Y29uc3QgZ3JvdXBOb2RlcyA9IG5ldyBTZXQoKTtcclxuXHJcblx0XHRteXBhcnNlZF9kYXRhLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcblx0XHRcdGlmIChub2RlLnR5cGUgPT09IFwiZ3JvdXBcIikge1xyXG5cdFx0XHRcdC8vIFRPRE8gbGF0ZXIgd2UgYWxzbyBoYW5kbGUgZ3JvdXBzXHJcblx0XHRcdFx0Z3JvdXBOb2Rlcy5hZGQobm9kZS5pZCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c2luZ2xlTm9kZUlEcy5hZGQobm9kZS5pZCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIEV4dHJhY3QgdW5pcXVlIGZyb21Ob2RlcyBhbmQgdG9Ob2Rlc1xyXG5cdFx0Y29uc3QgZnJvbU5vZGVzID0gbmV3IFNldCgpO1xyXG5cdFx0Y29uc3QgdG9Ob2RlcyA9IG5ldyBTZXQoKTtcclxuXHRcdGxldCBncm91cENsZWFyZWRFZGdlcyA9IFtdO1xyXG5cclxuXHRcdGxldCByZXNhID0gYXdhaXQgbXlwYXJzZWRfZGF0YS5lZGdlcy5mb3JFYWNoKGVkZ2UgPT4ge1xyXG5cclxuXHRcdFx0Ly8gVE9ETyBsYXRlciB3ZSBhbHNvIGhhbmRsZSBncm91cHNcclxuXHRcdFx0aWYgKGdyb3VwTm9kZXMuaGFzKGVkZ2UuZnJvbU5vZGUpIHx8IGdyb3VwTm9kZXMuaGFzKGVkZ2UudG9Ob2RlKSkge1xyXG5cdFx0XHRcdC8vIHJlbW92ZSBlZGdlIGZyb20gbXlwYXJzZWRfZGF0YVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZyb21Ob2Rlcy5hZGQoZWRnZS5mcm9tTm9kZSk7XHJcblx0XHRcdFx0dG9Ob2Rlcy5hZGQoZWRnZS50b05vZGUpO1xyXG5cdFx0XHRcdGdyb3VwQ2xlYXJlZEVkZ2VzLnB1c2goZWRnZSlcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRteXBhcnNlZF9kYXRhLmVkZ2VzMj1ncm91cENsZWFyZWRFZGdlcztcclxuXHJcblx0XHRsZXQgaGFuZGxlZE5vZGVzID0gbmV3IFNldCgpO1xyXG5cdFx0Ly8gVE9ETyBtYWtlIHRoaXMgYSBzZXR0aW5nXHJcblx0XHRjb25zdCBza2lwaGFuZGxlZE5vZGVzID0gdHJ1ZVxyXG5cclxuXHRcdGxldCBub2Rlc1dpdGhvdXRQYXJlbnRzID0gWy4uLnNpbmdsZU5vZGVJRHNdLmZpbHRlcihub2RlID0+ICF0b05vZGVzLmhhcyhub2RlKSk7XHJcblxyXG5cdFx0aWYgKG5vZGVzV2l0aG91dFBhcmVudHMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdG5vZGVzV2l0aG91dFBhcmVudHMgPSBbLi4uc2luZ2xlTm9kZUlEc107XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmlyc3Qgcm91bmQgb2Ygbm9kZXMgd2l0aG91dCBwYXJlbnRzXHJcblx0XHRjb25zdCB0cmF2ZXJzZXJlc3VsdCA9IGF3YWl0IHRoaXMudHJhdmVyc2VOb2Rlcyhub2Rlc1dpdGhvdXRQYXJlbnRzLCBteXBhcnNlZF9kYXRhLCBmaWxlQ29udGVudHMsIGhhbmRsZWROb2Rlcyk7XHJcblxyXG5cdFx0Y29uc3QgZGlmZiA9IG5ldyBTZXQoWy4uLnNpbmdsZU5vZGVJRHNdLmZpbHRlcih4ID0+ICFoYW5kbGVkTm9kZXMuaGFzKHgpKSk7XHJcblx0XHRcclxuXHRcdC8vIGlmIGRpZmYgaXMgbm90IGVtcHR5LCB3ZSBoYXZlIG5vZGVzIHdpdGhvdXQgcGFyZW50cyBhbmQgZ2l2ZSB0aGVtIHRvIGZpbmRBbGxYQ2hpbGRyZW4gYWdhaW5cclxuXHRcdGlmIChkaWZmLnNpemUgPiAwKSB7XHJcblx0XHRcdGNvbnN0IHRyYXZlcnNlcmVzdWx0ID0gYXdhaXQgdGhpcy50cmF2ZXJzZU5vZGVzKGRpZmYsIG15cGFyc2VkX2RhdGEsIGZpbGVDb250ZW50cywgaGFuZGxlZE5vZGVzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gW2ZpbGVDb250ZW50cywgbXlwYXJzZWRfZGF0YV07XHJcblx0fVxyXG5cclxuXHRhc3luYyBmb3JtYXROb2RlKG5vZGUsIGxldmVsKTogUHJvbWlzZTxbc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgbnVtYmVyLCBzdHJpbmcsIHN0cmluZ10+IHtcclxuXHRcdGNvbnN0IGlkID0gbm9kZS5pZDtcclxuXHRcdGNvbnN0IHR5cGUgPSBub2RlLnR5cGU7XHJcblx0XHRsZXQgbm9kZWZpbGUgPSBcIlwiO1xyXG5cclxuXHRcdGlmICh0eXBlID09PSBcImZpbGVcIikge1xyXG5cdFx0XHRub2RlZmlsZSA9IG5vZGUuZmlsZTtcclxuXHJcblx0XHRcdGNvbnN0IHsgbmFtZSwgZXh0IH0gPSBwYXRoLnBhcnNlKG5vZGVmaWxlKTtcclxuXHJcblx0XHRcdGlmIChleHQgPT09IFwiLm1kXCIpIHtcclxuXHRcdFx0XHRyZXR1cm4gW2lkLCB0eXBlLCBub2RlZmlsZSwgbGV2ZWwsIFwidGV4dGZpbGVcIiwgbmFtZV07XHJcblx0XHRcdH0gZWxzZSBpZiAoZXh0ID09PSBcIi5qcGdcIiB8fCBleHQgPT0gXCIuanBlZ1wiIHx8IGV4dCA9PT0gXCIucG5nXCIgfHwgZXh0ID09PSBcIi5naWZcIikge1xyXG5cdFx0XHRcdHJldHVybiBbaWQsIHR5cGUsIG5vZGVmaWxlLCBsZXZlbCwgXCJjb250ZW50aW1hZ2VcIiwgbmFtZSArIFwiLlwiICsgZXh0XTtcclxuXHRcdFx0fSBlbHNlIGlmIChleHQgPT09IFwiLnBkZlwiKSB7XHJcblx0XHRcdFx0cmV0dXJuIFtpZCwgdHlwZSwgbm9kZWZpbGUsIGxldmVsLCBcImNvbnRlbnRwZGZcIiwgbmFtZSArIFwiLlwiICsgZXh0XTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvL1RPRE8gaGFuZGxlIHVua25vd24gZmlsZSB0eXBlXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwibGlua1wiKSB7XHJcblx0XHRcdGlmIChub2RlLnVybC5pbmNsdWRlcyhcInlvdXR1YmVcIikpIHtcclxuXHRcdFx0XHRjb25zdCB1cmwgPSBub2RlLnVybDtcclxuXHRcdFx0XHRyZXR1cm4gW2lkLCB0eXBlLCB1cmwsIGxldmVsLCBcImNvbnRlbnR5b3V0dWJlXCIsIG5vZGUudXJsXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gW2lkLCB0eXBlLCBub2RlLnVybCwgbGV2ZWwsIFwiY29udGVudGxpbmtcIiwgbm9kZS51cmxdO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09IFwidGV4dFwiKSB7XHJcblx0XHRcdGNvbnN0IHRleHQgPSBub2RlLnRleHQ7XHJcblx0XHRcdC8vIGdldCBmaXJzdCAxMDAgY2hhcnMgb2YgdGV4dFxyXG5cdFx0XHRjb25zdCB0ZXh0UHJldmlldyA9IHRleHQuc3Vic3RyaW5nKDAsIDEwMCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gW2lkLCB0eXBlLCBcIm5vZGVcIiwgbGV2ZWwsIHRleHQsIHRleHRQcmV2aWV3XTtcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0YXN5bmMgd3JpdGVDYW52RG9jRmlsZShjb250ZW50LCBjb252U3RydWN0LCBteXBhcnNlZF9kYXRhKSB7XHJcblx0XHQvLyBlc3RhYmxpc2hpbmcgdGhlIHdvcmtkaXJcclxuXHRcdGxldCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcclxuXHRcdGxldCBtZEZvbGRlclBhdGg6IHN0cmluZyA9IHBhdGguZGlybmFtZShhY3RpdmVGaWxlLnBhdGgpO1xyXG5cclxuXHRcdGxldCB3cml0ZXdvcmtkaXIgPSBtZEZvbGRlclBhdGggKyBcIi9cIiArIGFjdGl2ZUZpbGUuYmFzZW5hbWUgKyBcIl9jYW52YXMyZG9jLWRhdGFcIlxyXG5cdFx0dGhpcy5mc2FkYXB0ZXIubWtkaXIod3JpdGV3b3JrZGlyKVxyXG5cclxuXHRcdGxldCBjYW52YXNGaWxlXHJcblx0XHRsZXQgY2FudmFzRmlsZW5hbWVcclxuXHRcdGlmIChtZEZvbGRlclBhdGggPT0gXCIuXCIpIHtcclxuXHQgICAgXHRjYW52YXNGaWxlbmFtZSA9IGFjdGl2ZUZpbGUuYmFzZW5hbWUgKyBcIl9mcm9tQ2FudmFzLm1kXCJcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNhbnZhc0ZpbGVuYW1lID0gbWRGb2xkZXJQYXRoICsgXCIvXCIgKyBhY3RpdmVGaWxlLmJhc2VuYW1lICsgXCJfZnJvbUNhbnZhcy5tZFwiXHRcdFx0XHRcdFxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjb250ZW50U3RyaW5nID0gXCI+IFshaW5mb10gVGhpcyBpcyBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBkb2N1bWVudCBmcm9tIFBsdWdpbiBbQ2FudmFzMkRvY3VtZW50XShodHRwczovL2dpdGh1Yi5jb20vc2xuc3lzL29ic2lkaWFuLWNhbnZhczJkb2N1bWVudClcXG5cXD4gYXJyYW5nZSB0aGUgZG9jdW1lbnQgYXMgeW91IG5lZWQgd2l0aCB0aGUgb3V0bGluZSwgdGhlbiBjYWxsICpDbGVhciBjYW52YXMyZG9jdW1lbnQgdGFyZ2V0IGRvY3VtZW50KlxcblxcblwiXHJcblxyXG5cdFx0Zm9yIChjb25zdCBlbGVtZW50IG9mIGNvbnRlbnQpIHtcclxuXHRcdFx0XHJcblx0XHRcdGxldCBjbmZuYW1lID0gXCJcIlxyXG5cclxuXHRcdFx0Ly8gcGxhY2UgbnVtYmVyIG9mICMgYWNjb3JkaW5nIHRvIGxldmVsXHJcblx0XHRcdGxldCBoZWFkaW5nID0gXCJcIlxyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50WzNdOyBpKyspIHtcclxuXHRcdFx0XHRoZWFkaW5nICs9IFwiI1wiXHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGlmIChlbGVtZW50WzFdID09IFwidGV4dFwiKSB7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Y25mbmFtZSA9IHdyaXRld29ya2RpciArIFwiL1wiICsgXCJuZXdkb2Mtbm9kZV9cIiArIGVsZW1lbnRbMF0gKyBcIl9mcm9tQ2FudmFzLm1kXCJcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRjb250ZW50U3RyaW5nICs9IFwiXFxuXFxuXCIgKyBoZWFkaW5nICsgXCIgX2NhcmQgXCIgKyBlbGVtZW50WzVdICsgXCJcXG5cIlxyXG5cdFx0XHRcdGNvbnRlbnRTdHJpbmcgKz0gZWxlbWVudFsyXSArIFwiIF5cIiArIGVsZW1lbnRbMF0gKyBcIlxcblxcblwiXHJcblx0XHRcdFx0Y29udGVudFN0cmluZyArPSBcIj4gWyF0aXBdIGxpbmsgbmF2aWdhdGlvbiBmcm9tIHRoZSBjYW52YXNcXG5cIlxyXG5cclxuXHRcdFx0XHRmb3IgKGNvbnN0IGVkZ2Ugb2YgbXlwYXJzZWRfZGF0YS5lZGdlczIpIHtcclxuXHRcdFx0XHRcdGlmIChlZGdlLmZyb21Ob2RlID09IGVsZW1lbnRbMF0pIHtcclxuXHRcdFx0XHRcdFx0Y29uc3QgZm91bmQgPSBjb250ZW50LmZpbmQoKGVsZW1lbnQpID0+IGVsZW1lbnRbMF0gPT0gZWRnZS50b05vZGUpO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBmaXJzdGxpbmUgPSBmb3VuZFs1XS5zcGxpdCgnXFxuJylbMF1cclxuXHRcdFx0XHRcdFx0Y29uc3QgZm91bmQ1ID0gZmlyc3RsaW5lLnJlcGxhY2UoLyMvZywgXCJcIilcclxuXHJcblx0XHRcdFx0XHRcdGNvbnRlbnRTdHJpbmcgKz0gXCI+IGxpbmtpbmcgdG86IFtbI15cIiArIGVkZ2UudG9Ob2RlICsgXCJ8XCIgKyBmb3VuZDUgKyBcIl1dXFxuXCJcclxuXHRcdFx0XHRcdH0gXHJcblx0XHRcdFx0XHRpZiAoZWRnZS50b05vZGUgPT0gZWxlbWVudFswXSkge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBmb3VuZCA9IGNvbnRlbnQuZmluZCgoZWxlbWVudCkgPT4gZWxlbWVudFswXSA9PSBlZGdlLmZyb21Ob2RlKTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgZmlyc3RsaW5lID0gZm91bmRbNV0uc3BsaXQoJ1xcbicpWzBdXHJcblx0XHRcdFx0XHRcdGNvbnN0IGZvdW5kNSA9IGZpcnN0bGluZS5yZXBsYWNlKC8jL2csIFwiXCIpXHJcblxyXG5cdFx0XHRcdFx0XHRjb250ZW50U3RyaW5nICs9IFwiPiBsaW5rZWQgZnJvbTogW1sjXlwiICsgZWRnZS5mcm9tTm9kZSArIFwifFwiICsgZm91bmQ1ICsgXCJdXVxcblwiXHJcblx0XHRcdFx0XHR9IFxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9FbWJlZGRpbmdcclxuXHRcdFx0XHRjb250ZW50U3RyaW5nICs9IFwiXFxuICFbW1wiICsgY25mbmFtZSArIFwiXV1cXG5cXG5cIlxyXG5cclxuXHRcdFx0XHRsZXQgY2FudmFzbm9kZUZpbGVcclxuXHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGxldCBjbmZhYnN0ID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGNuZm5hbWUpO1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5mc2FkYXB0ZXIud3JpdGUoY25mbmFtZSwgZWxlbWVudFs0XSlcclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhlKVxyXG5cdFx0XHRcdFx0cmV0dXJuXHJcblx0XHRcdFx0fVx0XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKGVsZW1lbnRbMV0gPT0gXCJsaW5rXCIpIHtcclxuXHRcdFx0XHQvLyBjbmZuYW1lID0gd3JpdGV3b3JrZGlyICsgXCIvXCIgKyBcIm5ld2RvYy1ub2RlX1wiICsgZWxlbWVudFswXSArIFwiIF9mcm9tQ2FudmFzLm1kXCJcclxuXHJcblx0XHRcdFx0Y29udGVudFN0cmluZyArPSBcIlxcblxcblwiICsgaGVhZGluZyArIFwiIF9saW5rIFwiICsgZWxlbWVudFs1XSArIFwiXFxuXCJcclxuXHRcdFx0XHRjb250ZW50U3RyaW5nICs9IGVsZW1lbnRbMl0gKyBcIiBeXCIgKyBlbGVtZW50WzBdICsgXCJcXG5cXG5cIlxyXG5cdFx0XHRcdGNvbnRlbnRTdHJpbmcgKz0gXCI+IFshdGlwXSBsaW5rIG5hdmlnYXRpb24gZnJvbSB0aGUgY2FudmFzXFxuXCJcclxuXHJcblx0XHRcdFx0Zm9yIChjb25zdCBlZGdlIG9mIG15cGFyc2VkX2RhdGEuZWRnZXMyKSB7XHJcblx0XHRcdFx0XHRpZiAoZWRnZS5mcm9tTm9kZSA9PSBlbGVtZW50WzBdKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGZvdW5kID0gY29udGVudC5maW5kKChlbGVtZW50KSA9PiBlbGVtZW50WzBdID09IGVkZ2UudG9Ob2RlKTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgZmlyc3RsaW5lID0gZm91bmRbNV0uc3BsaXQoJ1xcbicpWzBdXHJcblx0XHRcdFx0XHRcdGNvbnN0IGZvdW5kNSA9IGZpcnN0bGluZS5yZXBsYWNlKC8jL2csIFwiXCIpXHJcblxyXG5cdFx0XHRcdFx0XHRjb250ZW50U3RyaW5nICs9IFwiPiBsaW5raW5nIHRvOiBbWyNeXCIgKyBlZGdlLnRvTm9kZSArIFwifFwiICsgZm91bmQ1ICsgXCJdXVxcblwiXHJcblx0XHRcdFx0XHR9IFxyXG5cdFx0XHRcdFx0aWYgKGVkZ2UudG9Ob2RlID09IGVsZW1lbnRbMF0pIHtcclxuXHRcdFx0XHRcdFx0Y29uc3QgZm91bmQgPSBjb250ZW50LmZpbmQoKGVsZW1lbnQpID0+IGVsZW1lbnRbMF0gPT0gZWRnZS5mcm9tTm9kZSk7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGZpcnN0bGluZSA9IGZvdW5kWzVdLnNwbGl0KCdcXG4nKVswXVxyXG5cdFx0XHRcdFx0XHRjb25zdCBmb3VuZDUgPSBmaXJzdGxpbmUucmVwbGFjZSgvIy9nLCBcIlwiKVxyXG5cclxuXHRcdFx0XHRcdFx0Y29udGVudFN0cmluZyArPSBcIj4gbGlua2VkIGZyb206IFtbI15cIiArIGVkZ2UuZnJvbU5vZGUgKyBcInxcIiArIGZvdW5kNSArIFwiXV1cXG5cIlxyXG5cdFx0XHRcdFx0fSBcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vRW1iZWRkaW5nIG1lZGlhIHNwZWNpZmljXHJcblx0XHRcdFx0Ly8gVE9ETyBhbHNvIGFkZCBuYXZpZ2F0aW9uYWwgdGl0bGUgZGF0YSB0byBlbGVtZW50IG1ldGFib3hcclxuXHRcdFx0XHRpZiAoZWxlbWVudFs0XSA9PSBcImNvbnRlbnR5b3V0dWJlXCIpIHtcclxuXHRcdFx0XHRcdGNvbnRlbnRTdHJpbmcgKz0gXCJcXG4gIVtdKFwiICsgZWxlbWVudFsyXSArIFwiKVxcblxcblwiXHJcblx0XHRcdFx0fSBlbHNlIGlmIChlbGVtZW50WzRdID09IFwiY29udGVudGxpbmtcIikge1xyXG5cdFx0XHRcdFx0Y29udGVudFN0cmluZyArPSBcIlxcbiA8aWZyYW1lIHNyYz1cXFwiXCIgKyBlbGVtZW50WzJdICsgXCJcXFwiPjwvaWZyYW1lPlxcblxcblwiXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmIChlbGVtZW50WzFdID09IFwiZmlsZVwiKSB7XHJcblx0XHRcdFx0aWYgKGVsZW1lbnRbNF0gPT0gXCJjb250ZW50aW1hZ2VcIiB8fCBlbGVtZW50WzRdID09IFwiY29udGVudHBkZlwiKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29udGVudFN0cmluZyArPSBcIlxcblxcblwiICsgaGVhZGluZyArIFwiIF9NZWRpYSBcIiArIGVsZW1lbnRbNV0gKyBcIlxcblwiXHJcblx0XHRcdFx0XHRjb250ZW50U3RyaW5nICs9IGVsZW1lbnRbMl0gKyBcIiBeXCIgKyBlbGVtZW50WzBdICsgXCJcXG5cXG5cIlxyXG5cdFx0XHRcdFx0Ly8gVE9ETyBsaW5raW5nIGJveCBub2NoIGluIGZ1bmt0aW9uIGF1c2xhZ2VyblxyXG5cdFx0XHRcdFx0Y29udGVudFN0cmluZyArPSBcIj4gWyF0aXBdIGxpbmsgbmF2aWdhdGlvbiBmcm9tIHRoZSBjYW52YXNcXG5cIlxyXG5cclxuXHRcdFx0XHRcdGZvciAoY29uc3QgZWRnZSBvZiBteXBhcnNlZF9kYXRhLmVkZ2VzMikge1xyXG5cdFx0XHRcdFx0XHRpZiAoZWRnZS5mcm9tTm9kZSA9PSBlbGVtZW50WzBdKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgZm91bmQgPSBjb250ZW50LmZpbmQoKGVsZW1lbnQpID0+IGVsZW1lbnRbMF0gPT0gZWRnZS50b05vZGUpO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGZpcnN0bGluZSA9IGZvdW5kWzVdLnNwbGl0KCdcXG4nKVswXVxyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGZvdW5kNSA9IGZpcnN0bGluZS5yZXBsYWNlKC8jL2csIFwiXCIpXHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnRlbnRTdHJpbmcgKz0gXCI+IGxpbmtpbmcgdG86IFtbI15cIiArIGVkZ2UudG9Ob2RlICsgXCJ8XCIgKyBmb3VuZDUgKyBcIl1dXFxuXCJcclxuXHRcdFx0XHRcdFx0fSBcclxuXHRcdFx0XHRcdFx0aWYgKGVkZ2UudG9Ob2RlID09IGVsZW1lbnRbMF0pIHtcclxuXHRcdFx0XHRcdFx0XHRjb25zdCBmb3VuZCA9IGNvbnRlbnQuZmluZCgoZWxlbWVudCkgPT4gZWxlbWVudFswXSA9PSBlZGdlLmZyb21Ob2RlKTtcclxuXHRcdFx0XHRcdFx0XHRjb25zdCBmaXJzdGxpbmUgPSBmb3VuZFs1XS5zcGxpdCgnXFxuJylbMF1cclxuXHRcdFx0XHRcdFx0XHRjb25zdCBmb3VuZDUgPSBmaXJzdGxpbmUucmVwbGFjZSgvIy9nLCBcIlwiKVx0XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnRlbnRTdHJpbmcgKz0gXCI+IGxpbmtlZCBmcm9tOiBbWyNeXCIgKyBlZGdlLmZyb21Ob2RlICsgXCJ8XCIgKyBmb3VuZDUgKyBcIl1dXFxuXCJcclxuXHRcdFx0XHRcdFx0fSBcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vIHN0YXJ0dGFnIG1ldGEgZGF0YSBibG9ja1xyXG5cdFx0XHRcdFx0Ly8gY29udGVudFN0cmluZyArPSBcIlxcbiUlXFxuY2FudmFzMmRvY3VtZW50IHBsdWdpbiBtZXRhZGF0YSBoZWFkZXIgZW5kXFxuJSVcXG5cIlxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdFx0Ly9FbWJlZGRpbmcgbWVkaWEgc3BlY2lmaWNcclxuXHRcdFx0XHRcdGlmIChlbGVtZW50WzRdID09IFwiY29udGVudHBkZlwiKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRlbnRTdHJpbmcgKz0gXCJcXG4gIVtbXCIgKyBlbGVtZW50WzJdICsgXCIjaGVpZ2h0PTUwMF1dXFxuXFxuXCJcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZWxlbWVudFs0XSA9PSBcImNvbnRlbnRpbWFnZVwiKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRlbnRTdHJpbmcgKz0gXCJcXG4gIVtbXCIgKyBlbGVtZW50WzJdICsgXCJ8NTAwXV1cXG5cXG5cIlxyXG5cdFx0XHRcdFx0fVx0XHRcdFx0XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBUT0RPIGNvbmZpcm0sIHRoYXQgZmlsZSBpcyBtZCwgbm90IHRoZSBlbHNlIGNhc2VcclxuXHJcblx0XHRcdFx0XHRjb250ZW50U3RyaW5nICs9IFwiXFxuXFxuXCIgKyBoZWFkaW5nICsgXCIgX25vdGVGaWxlIFwiICsgZWxlbWVudFs1XSArIFwiXFxuXCJcclxuXHRcdFx0XHRcdGNvbnRlbnRTdHJpbmcgKz0gZWxlbWVudFsyXSArIFwiIF5cIiArIGVsZW1lbnRbMF0gKyBcIlxcblxcblwiXHJcblx0XHRcdFx0XHRjb250ZW50U3RyaW5nICs9IFwiPiBbIXRpcF0gbGluayBuYXZpZ2F0aW9uIGZyb20gdGhlIGNhbnZhc1xcblwiXHJcblxyXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBlZGdlIG9mIG15cGFyc2VkX2RhdGEuZWRnZXMyKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoZWRnZS5mcm9tTm9kZSA9PSBlbGVtZW50WzBdKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgZm91bmQgPSBjb250ZW50LmZpbmQoKGVsZW1lbnQpID0+IGVsZW1lbnRbMF0gPT0gZWRnZS50b05vZGUpO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGZpcnN0bGluZSA9IGZvdW5kWzVdLnNwbGl0KCdcXG4nKVswXVxyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGZvdW5kNSA9IGZpcnN0bGluZS5yZXBsYWNlKC8jL2csIFwiXCIpXHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnRlbnRTdHJpbmcgKz0gXCI+IGxpbmtpbmcgdG86IFtbI15cIiArIGVkZ2UudG9Ob2RlICsgXCJ8XCIgKyBmb3VuZDUgKyBcIl1dXFxuXCJcclxuXHRcdFx0XHRcdFx0fSBcclxuXHRcdFx0XHRcdFx0aWYgKGVkZ2UudG9Ob2RlID09IGVsZW1lbnRbMF0pIHtcclxuXHRcdFx0XHRcdFx0XHRjb25zdCBmb3VuZCA9IGNvbnRlbnQuZmluZCgoZWxlbWVudCkgPT4gZWxlbWVudFswXSA9PSBlZGdlLmZyb21Ob2RlKTtcclxuXHRcdFx0XHRcdFx0XHRjb25zdCBmaXJzdGxpbmUgPSBmb3VuZFs1XS5zcGxpdCgnXFxuJylbMF1cclxuXHRcdFx0XHRcdFx0XHRjb25zdCBmb3VuZDUgPSBmaXJzdGxpbmUucmVwbGFjZSgvIy9nLCBcIlwiKVx0XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnRlbnRTdHJpbmcgKz0gXCI+IGxpbmtlZCBmcm9tOiBbWyNeXCIgKyBlZGdlLmZyb21Ob2RlICsgXCJ8XCIgKyBmb3VuZDUgKyBcIl1dXFxuXCJcclxuXHRcdFx0XHRcdFx0fSBcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHRcdC8vIEVtYmVkZGluZ1xyXG5cdFx0XHRcdFx0Y29udGVudFN0cmluZyArPSBcIlxcbiAhW1tcIiArICBlbGVtZW50WzJdICsgXCJdXVxcblxcblwiXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdH1cclxuXHJcbiAgIFx0ICAgIHRyeSB7XHJcblx0XHRcdFx0Y29uc3QgZXhpc3RzID0gYXdhaXQgdGhpcy5mc2FkYXB0ZXIuZXhpc3RzKGNhbnZhc0ZpbGVuYW1lKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZiAoZXhpc3RzKSB7XHJcblx0XHRcdFx0ICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IG5vdGljZSA9IG5ldyBOb3RpY2UoJ0ZpbGUgJyArIGNhbnZhc0ZpbGVuYW1lICsgJyBhbHJlYWR5IGV4aXN0cy4gT3ZlcndyaXRlPycsIDApO1xyXG5cdFx0XHRcdFx0bm90aWNlLm5vdGljZUVsLmNyZWF0ZUVsKCdidXR0b24nLCB7dGV4dDogJ1llcyd9KS5vbmNsaWNrID0gKCkgPT4ge1xyXG5cdFx0XHRcdFx0ICBub3RpY2UuaGlkZSgpO1xyXG5cdFx0XHRcdFx0ICByZXNvbHZlKHRydWUpO1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdG5vdGljZS5ub3RpY2VFbC5jcmVhdGVFbCgnYnV0dG9uJywge3RleHQ6ICdObyd9KS5vbmNsaWNrID0gKCkgPT4ge1xyXG5cdFx0XHRcdFx0ICBub3RpY2UuaGlkZSgpO1xyXG5cdFx0XHRcdFx0ICByZXNvbHZlKGZhbHNlKTtcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0ICB9KTtcclxuXHRcdFx0XHQgIFxyXG5cdFx0XHRcdCAgaWYgKCFjb25maXJtZWQpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gVXNlciBjaG9zZSBub3QgdG8gb3ZlcndyaXRlXHJcblx0XHRcdFx0ICB9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGF3YWl0IHRoaXMuZnNhZGFwdGVyLndyaXRlKGNhbnZhc0ZpbGVuYW1lLCBjb250ZW50U3RyaW5nKTtcclxuXHJcblx0ICAgIC8vICAgY2FudmFzRmlsZSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShjYW52YXNGaWxlbmFtZSwgY29udGVudFN0cmluZylcclxuXHQgICAgfSBjYXRjaCAoZSkge1xyXG5cdFx0XHRjb25zb2xlLmxvZyhcImVycm9yIHdyaXRpbmcgdGhlIG5ldyBkb2MgZmlsZSBcIiArIGUpXHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgY25mYWJzdCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChjYW52YXNGaWxlbmFtZSk7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0YXdhaXQgdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoJ3NwbGl0Jykub3BlbkZpbGUoY25mYWJzdCk7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKGUpXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZVxyXG5cclxuXHR9XHJcbn1cclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBNkg7QUFFN0gsV0FBc0I7QUFHdEIsSUFBcUIsd0JBQXJCLGNBQW1ELHVCQUFPO0FBQUEsRUFHekQsTUFBTSxTQUFTO0FBR2IsUUFBSSxLQUFLLElBQUksTUFBTSxtQkFBbUIsbUNBQW1CO0FBQ3pELFdBQUssWUFBWSxLQUFLLElBQUksTUFBTTtBQUFBLElBQ2hDLE9BQU87QUFFUDtBQUFBLElBQ0E7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNmLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsWUFBWTtBQUNyQixjQUFNLGFBQWEsTUFBTSxLQUFLLGlCQUFpQjtBQUMvQyxZQUFJLGNBQWMsT0FBTztBQUN4QixjQUFJLHVCQUFPLDJCQUEyQjtBQUN0QztBQUFBLFFBQ0Q7QUFFQSxZQUFJLENBQUMsVUFBVSxhQUFhLElBQUksTUFBTSxLQUFLLGVBQWUsVUFBVTtBQUVwRSxjQUFNLFNBQVMsTUFBTSxLQUFLLGlCQUFpQixVQUFVLFlBQVksYUFBYTtBQUFBLE1BRS9FO0FBQUEsSUFDRCxDQUFDO0FBRUQsU0FBSyxX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O0FBQ3JGLGlCQUFPLFNBQVMsU0FBUyxVQUFVLEVBQUMsTUFBTSxNQUFLLENBQUMsRUFBRSxVQUFVLE1BQU07QUFDaEUsbUJBQU8sS0FBSztBQUNaLG9CQUFRLElBQUk7QUFBQSxVQUNkO0FBQ0EsaUJBQU8sU0FBUyxTQUFTLFVBQVUsRUFBQyxNQUFNLEtBQUksQ0FBQyxFQUFFLFVBQVUsTUFBTTtBQUMvRCxtQkFBTyxLQUFLO0FBQ1osb0JBQVEsS0FBSztBQUFBLFVBQ2Y7QUFBQSxRQUNDLENBQUM7QUFFRCxZQUFJLENBQUMsV0FBVztBQUNqQixpQkFBTztBQUFBLFFBQ047QUFBQSxNQUNGO0FBRUEsWUFBTSxLQUFLLFVBQVUsTUFBTSxnQkFBZ0IsYUFBYTtBQUFBLElBR3ZELFNBQVMsR0FBUDtBQUNKLGNBQVEsSUFBSSxvQ0FBb0MsQ0FBQztBQUFBLElBQ2xEO0FBRUEsVUFBTSxVQUFVLE1BQU0sS0FBSyxJQUFJLE1BQU0sc0JBQXNCLGNBQWM7QUFFekUsUUFBSTtBQUNILFlBQU0sS0FBSyxJQUFJLFVBQVUsUUFBUSxPQUFPLEVBQUUsU0FBUyxPQUFPO0FBQUEsSUFDM0QsU0FBUyxHQUFQO0FBQ0QsY0FBUSxJQUFJLENBQUM7QUFBQSxJQUNkO0FBQ0EsV0FBTztBQUFBLEVBRVI7QUFDRDsiLAogICJuYW1lcyI6IFsibm9kZWVudHJ5IiwgInJlc3VsdCIsICJ0cmF2ZXJzZXJlc3VsdCIsICJlbGVtZW50IiwgImNuZmFic3QiXQp9Cg==
